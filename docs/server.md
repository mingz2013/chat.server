客户端和服务器通信

客户端请求,服务器响应

客户端发送心跳包,来请求服务器响应

服务器不主动向客户端推送消息,只通过心跳包推送消息

跟web开发就一样了

只需要底层连接保证连接

上层一样

消息存储在数据库,当要推送消息的时候,从数据库拿出来推出去


如果接受消息的用户在线,直接推送,如果不在线,存储到数据库,等待心跳包


就是客户端需要给服务器回应retcode，服务器也需要给客户端回应retcode

packet 只定义发送的包,回应包很简单,很固定,

心跳包机制
客户端发送,或者服务器发送,逻辑层判断是否存活
心跳包一般来说都是在逻辑层发送空的echo包来实现的。
下一个定时器，在一定时间间隔下发送一个空包给客户端，
然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定说掉线了。

心跳检测步骤：
1客户端每隔一个时间间隔发生一个探测包给服务器
2客户端发包时启动一个超时定时器
3服务器端接收到检测包，应该回应一个包
4如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器
5如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了
转自：http://blog.sina.com.cn/s/blog_a459dcf5010153m5.html





engine.io 不支持断线重连,看看socket.io, 或者其他人为engino写的reconnect库

换用socket.io 解决自动重连,心跳包问题

客户端发给服务器,服务器返回retcode响应,服务器发给客户端,客户端不返回retcode

---


前端服务器会调用connector的send函数将响应或者推送的消息发送给客户端，
send调用不会直接将要发送的消息通过socket直接发送给客户端，
而是将发送任务调度给CoPushScheduler，
CoPushScheduler可以实现具体的发送策略。
pomelo中提供了两种方式的pushScheduler，
direct会立即将用户的响应发送给用户，
buffer则会缓冲发送任务，并按时冲刷，
pomelo默认使用的是direct的方式，
如果想使用buffer的方式，可以通过如下的调用启用: